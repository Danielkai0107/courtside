# 賽事管理系統重構測試指南

## 🎯 測試目標

驗證二階段發布機制、Linked List 自動晉級、場地管理和單淘汰賽制算法的完整性。

---

## 📋 測試前準備

### 1. 部署 Firestore Rules 和 Indexes

```bash
# 部署安全規則
firebase deploy --only firestore:rules

# 部署索引
firebase deploy --only firestore:indexes
```

### 2. 清除測試數據（可選）

在 Firebase Console 中：

- 清除 `tournaments` 集合
- 清除 `matches` 集合
- 清除 `courts` 集合
- 保留 `users`、`players`、`staff` 集合

### 3. 啟動開發環境

```bash
npm run dev
```

---

## 🧪 完整測試流程

### 測試案例 1：單淘汰賽（3 人，無季軍賽）

#### 1.1 建立賽事（DRAFT）

1. 以主辦方身份登入
2. 點擊「建立賽事」
3. 填寫基本資訊：
   - 名稱：測試單淘汰賽
   - 日期：未來日期
   - 地點：測試場地
   - **賽制**：選擇「單淘汰」（`SINGLE_ELIM`）
   - **季軍賽**：關閉
4. 確認賽事狀態為 `DRAFT`（草稿）

#### 1.2 開放報名（REGISTRATION_OPEN）

1. 進入賽事儀表板
2. 點擊「開放報名」按鈕
3. 確認狀態變更為 `REGISTRATION_OPEN`（開放報名中）
4. 狀態標籤顯示「開放報名中」

#### 1.3 模擬選手報名

1. 新增 3 位選手：
   - 選手 A
   - 選手 B
   - 選手 C
2. 審核並確認所有報名
3. 確認「選手管理」Tab 顯示 3 位已確認選手

#### 1.4 截止報名（REGISTRATION_CLOSED）

1. 點擊「截止報名」按鈕
2. 確認狀態變更為 `REGISTRATION_CLOSED`（截止報名/籌備中）
3. **新 Tab 出現**：「賽程設定」Tab 應該顯示

#### 1.5 賽程設定（二階段發布核心）

**參賽者選擇**：

1. 進入「賽程設定」Tab
2. 看到 3 位已確認選手的 Checkbox 列表
3. 全選 3 人
4. 確認顯示「已選 3 人」

**賽制設定**：

1. 賽制類型：已選「單淘汰」
2. 季軍賽開關：關閉

**即時預覽**：

- 應顯示：「將產生 4 強賽程，共 3 場比賽（包含 1 個輪空位）」

**場地管理**：

1. 點擊「+ 新增場地」
2. 新增場地：「場地 A」
3. 新增場地：「場地 B」
4. 確認列表顯示 2 個場地

#### 1.6 發布賽程（ONGOING）

1. 點擊「生成賽程並發布」按鈕
2. 確認 Modal 顯示：
   - 參賽人數：3 人
   - 賽制：單淘汰
   - 場地數：2 個
   - 預計比賽：4 強賽程，共 3 場比賽（包含 1 個輪空位）
3. 點擊「確定發布」
4. 等待處理（約 2-3 秒）
5. 確認：
   - 狀態變更為 `ONGOING`（進行中）
   - 自動切換到「賽程管理」Tab

#### 1.7 驗證賽程結構（BracketView）

**第一輪**：

- 應有 2 場比賽
- **比賽 1**：選手 A vs 輪空 (BYE)
  - 狀態：`COMPLETED`（已完成）
  - 勝者：選手 A（自動晉級）
- **比賽 2**：選手 B vs 選手 C
  - 狀態：`SCHEDULED`（已排程）
  - 場地：場地 A 或 場地 B

**準決賽**：

- 應有 1 場比賽
- **決賽**：選手 A vs 待定
  - 狀態：`PENDING_PLAYER`（等待選手）
  - player1：選手 A（已晉級）
  - player2：null（等待第一輪比賽結果）

**視覺化檢查**：

- ✅ BYE 輪空顯示為灰色或特殊標記
- ✅ 場地名稱顯示在 Match Card 上
- ✅ 狀態標籤有顏色區分（綠色=已完成、藍色=已排程、灰色=等待）
- ✅ 輪次標籤正確：「第一輪」、「決賽」

#### 1.8 完成第一輪比賽（自動晉級測試）

1. 以紀錄員身份開始「比賽 2」（選手 B vs 選手 C）
2. 記錄比分：B 21 : C 15
3. 點擊「結束比賽」

**預期自動化行為**：

- ✅ 比賽 2 狀態變為 `COMPLETED`
- ✅ 場地 A 狀態變為 `IDLE`
- ✅ 勝者（選手 B）自動填入決賽的 `player2Id`
- ✅ 決賽狀態從 `PENDING_PLAYER` 變為 `PENDING_COURT`
- ✅ 決賽自動分配到空閒場地（場地 A）
- ✅ 決賽狀態變為 `SCHEDULED`

**在 BracketView 驗證**：

- 決賽應顯示：選手 A vs 選手 B
- 決賽狀態：`SCHEDULED`
- 決賽場地：場地 A

#### 1.9 完成決賽（冠軍產生）

1. 開始決賽
2. 記錄比分：A 21 : B 18
3. 結束比賽

**預期結果**：

- 決賽狀態：`COMPLETED`
- 勝者：選手 A
- 可考慮自動將賽事狀態改為 `COMPLETED`（需額外邏輯）

---

### 測試案例 2：單淘汰賽（7 人，啟用季軍賽）

#### 2.1 設定與報名

- 建立賽事
- 開放報名
- 新增 7 位選手並確認
- 截止報名

#### 2.2 賽程設定

- 選擇全部 7 人
- 賽制：單淘汰
- **季軍賽：啟用**
- 新增 3 個場地

**即時預覽**：

- 應顯示：「將產生 8 強賽程，共 8 場比賽（包含 1 個輪空位）」

#### 2.3 發布與驗證

**第一輪**：

- 4 場比賽（3 場正常 + 1 場 BYE）

**準決賽**：

- 2 場比賽
- 檢查 `loserNextMatchId` 是否指向季軍賽

**季軍賽**：

- Round = 3.5（特殊標記）
- 狀態：`PENDING_PLAYER`
- 顯示為「季軍賽」

**決賽**：

- Round = 4
- 顯示為「決賽」

#### 2.4 驗證敗部晉級

1. 完成第一場準決賽，敗者應自動填入季軍賽 `player1Id`
2. 完成第二場準決賽，敗者應自動填入季軍賽 `player2Id`
3. 季軍賽狀態變為 `PENDING_COURT`

---

### 測試案例 3：場地調度系統

#### 3.1 設定

- 8 位選手
- **僅 2 個場地**（模擬場地不足情況）

#### 3.2 發布後狀態

**第一輪（4 場比賽）**：

- 比賽 1：場地 A，狀態 `SCHEDULED`
- 比賽 2：場地 B，狀態 `SCHEDULED`
- 比賽 3：無場地，狀態 `PENDING_COURT`
- 比賽 4：無場地，狀態 `PENDING_COURT`

#### 3.3 驗證自動調度

1. **完成比賽 1**

   - 場地 A 釋放（`IDLE`）
   - 比賽 3 自動分配場地 A
   - 比賽 3 狀態變為 `SCHEDULED`

2. **完成比賽 2**

   - 場地 B 釋放
   - 比賽 4 自動分配場地 B
   - 比賽 4 狀態變為 `SCHEDULED`

3. **完成比賽 3 和 4**
   - 第二輪比賽自動分配場地

---

## 🔍 關鍵驗證點

### 資料完整性

1. **Match 的 Linked List 正確性**

   - 每場比賽的 `nextMatchId` 正確指向下一場
   - `nextMatchSlot` 正確標記 `player1` 或 `player2`
   - 季軍賽的 `loserNextMatchId` 正確設定

2. **BYE 自動晉級**

   - BYE 場次狀態為 `COMPLETED`
   - 勝者自動填入下一場
   - 不佔用真實場地

3. **Transaction 原子性**
   - 比賽完成、場地釋放、選手晉級應同時發生
   - 不應出現部分成功的情況

### UI/UX 驗證

1. **BracketView 顯示**

   - ✅ 輪次標籤正確
   - ✅ BYE 有特殊視覺標記
   - ✅ 場地名稱顯示
   - ✅ 狀態顏色區分
   - ✅ 響應式佈局（手機可橫向滾動）

2. **賽程設定 Tab**

   - ✅ 僅在 `REGISTRATION_CLOSED` 狀態顯示
   - ✅ 參賽者選擇即時更新人數
   - ✅ 即時預覽計算正確
   - ✅ 場地列表即時更新

3. **狀態轉換流暢性**
   - ✅ 按鈕在正確狀態顯示
   - ✅ 狀態轉換有明確提示
   - ✅ 錯誤處理友善

---

## 🐛 常見問題排查

### 問題 1：發布賽程失敗

**可能原因**：

- Firestore Rules 未部署
- Firestore Indexes 未建立

**解決方案**：

```bash
firebase deploy --only firestore:rules,firestore:indexes
```

### 問題 2：BYE 場次未自動完成

**檢查**：

- `bracketService.ts` 中的 `autoProgressByeMatches` 是否執行
- Console 是否有錯誤訊息

### 問題 3：場地調度失敗

**檢查**：

- `dispatchCourtToWaitingMatch` 是否被調用
- 是否有比賽狀態為 `PENDING_COURT`
- Courts 集合是否有 `IDLE` 場地

### 問題 4：選手未自動晉級

**檢查**：

- Match 的 `nextMatchId` 是否正確
- Transaction 是否成功執行
- Firestore Console 檢查 `nextMatch` 的 `player1Id` 或 `player2Id` 是否更新

---

## 📊 性能測試

### 大型賽事測試

- **32 人單淘汰**：31 場比賽
- **64 人單淘汰**：63 場比賽

**驗證點**：

- Batch Write 是否成功（一次最多 500 個操作）
- BracketView 渲染速度
- 場地調度效率

---

## ✅ 測試檢查清單

- [ ] 資料結構：Tournament、Match、Court 正確創建
- [ ] 狀態機：五階段狀態轉換流暢
- [ ] 算法：單淘汰賽程正確生成
- [ ] BYE：輪空自動晉級
- [ ] 季軍賽：敗部鏈結正確
- [ ] 自動晉級：勝者自動填入下一場
- [ ] 場地調度：空閒場地自動分配
- [ ] Transaction：原子操作無競態
- [ ] UI：BracketView 視覺化完整
- [ ] 二階段發布：參賽者選擇和即時預覽

---

## 🚀 下一步

測試通過後：

1. 部署到 Firebase Hosting
2. 更新用戶文檔
3. 準備雙敗淘汰算法實現
4. 實現循環賽重構

---

**測試愉快！🎉**
